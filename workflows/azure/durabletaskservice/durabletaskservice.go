package durabletaskservice

import (
	"context"
	"errors"
	"fmt"
	"reflect"
	"time"

	"github.com/dapr/components-contrib/common/authentication/azure"
	contribmeta "github.com/dapr/components-contrib/metadata"
	"github.com/dapr/components-contrib/workflows"
	"github.com/dapr/kit/logger"
	kitmd "github.com/dapr/kit/metadata"

	"github.com/microsoft/durabletask-go/api"
	"github.com/microsoft/durabletask-go/backend"
	dts "github.com/microsoft/durabletask-go/backend/azure/durabletaskservice"
)

type metadata struct {
	TaskHubName   string `mapstructure:"taskHubName"`
	Endpoint      string `mapstructure:"endpoint"`
	ResourceScope string `mapstructure:"resourceScope"`
	TenantID      string `mapstructure:"tenantID"`
	ClientID      string `mapstructure:"clientID"`
}

// Status values are defined at: https://github.com/microsoft/durabletask-go/blob/119b361079c45e368f83b223888d56a436ac59b9/internal/protos/orchestrator_service.pb.go#L42-L64
var statusMap = map[int32]string{
	0: "RUNNING",
	1: "COMPLETED",
	2: "CONTINUED_AS_NEW",
	3: "FAILED",
	4: "CANCELED",
	5: "TERMINATED",
	6: "PENDING",
	7: "SUSPENDED",
}

type DurableTaskService struct {
	logger     backend.Logger
	client     backend.TaskHubClient
	dtsBackend backend.Backend
}

func NewDurableTaskService(logger logger.Logger) workflows.Workflow {
	d := &DurableTaskService{
		logger: logger,
	}
	return d
}

func (d *DurableTaskService) Init(meta workflows.Metadata) error {
	var m metadata
	err := kitmd.DecodeMetadata(meta.Properties, &m)
	if err != nil {
		return err
	}

	var env azure.EnvironmentSettings
	env, err = azure.NewEnvironmentSettings(meta.Properties)
	if err != nil {
		return err
	}
	token, tokenErr := env.GetTokenCredential()
	if tokenErr != nil {
		return tokenErr
	}

	options := dts.DurableTaskServiceBackendOptions{
		Endpoint:        m.Endpoint,
		TaskHubHubName:  m.TaskHubName,
		ResourceScope:   m.ResourceScope,
		TenantID:        m.TenantID,
		ClientID:        m.ClientID,
		AzureCredential: token,
	}

	d.dtsBackend, err = dts.NewDurableTaskServiceBackend(&options, d.logger)
	d.client = backend.NewTaskHubClient(d.dtsBackend)

	return err
}

func (d *DurableTaskService) Start(ctx context.Context, req *workflows.StartRequest) (*workflows.StartResponse, error) {
	if req.WorkflowName == "" {
		return nil, errors.New("a workflow name is required")
	}

	// Init with capacity of 3 as worst-case scenario
	opts := make([]api.NewOrchestrationOptions, 0, 3)

	// Specifying the ID is optional - if not specified, a random ID will be generated by the client.
	if req.InstanceID != "" {
		opts = append(opts, api.WithInstanceID(api.InstanceID(req.InstanceID)))
	}

	// Input is also optional. However, inputs are expected to be unprocessed string values (e.g. JSON text)
	if len(req.WorkflowInput) > 0 {
		opts = append(opts, api.WithRawInput(string(req.WorkflowInput)))
	}

	// Start time is also optional and must be in the RFC3339 format (e.g. 2009-11-10T23:00:00Z).
	if req.Options != nil {
		if startTimeRFC3339, ok := req.Options["dapr.workflow.start_time"]; ok {
			if startTime, err := time.Parse(time.RFC3339, startTimeRFC3339); err != nil {
				return nil, errors.New(`start times must be in RFC3339 format (e.g. "2009-11-10T23:00:00Z")`)
			} else {
				opts = append(opts, api.WithStartTime(startTime))
			}
		}
	}

	workflowID, err := d.client.ScheduleNewOrchestration(ctx, req.WorkflowName, opts...)
	if err != nil {
		return nil, fmt.Errorf("unable to start workflow: %w", err)
	}

	d.logger.Debugf("Created new workflow '%s' instance with ID '%s'", req.WorkflowName, workflowID)
	res := &workflows.StartResponse{
		InstanceID: string(workflowID),
	}
	return res, nil
}

func (d *DurableTaskService) Terminate(ctx context.Context, req *workflows.TerminateRequest) error {
	if req.InstanceID == "" {
		return errors.New("a workflow instance ID is required")
	}

	if err := d.client.TerminateOrchestration(ctx, api.InstanceID(req.InstanceID), api.WithRecursiveTerminate(req.Recursive)); err != nil {
		if errors.Is(err, api.ErrInstanceNotFound) {
			d.logger.Infof("No such instance exists: '%s'", req.InstanceID)
			return err
		}
		return fmt.Errorf("failed to terminate workflow %s: %w", req.InstanceID, err)
	}

	d.logger.Debugf("Scheduled termination for workflow instance '%s'", req.InstanceID)
	return nil
}

func (d *DurableTaskService) Purge(ctx context.Context, req *workflows.PurgeRequest) error {
	if req.InstanceID == "" {
		return errors.New("a workflow instance ID is required")
	}

	if err := d.client.PurgeOrchestrationState(ctx, api.InstanceID(req.InstanceID), api.WithRecursivePurge(req.Recursive)); err != nil {
		if errors.Is(err, api.ErrInstanceNotFound) {
			d.logger.Warnf("Unable to purge the instance: '%s', no such instance exists", req.InstanceID)
			return err
		}
		return fmt.Errorf("failed to Purge workflow %s: %w", req.InstanceID, err)
	}
	d.logger.Debugf("Purging workflow instance '%s'", req.InstanceID)

	return nil
}

func (d *DurableTaskService) RaiseEvent(ctx context.Context, req *workflows.RaiseEventRequest) error {
	if req.InstanceID == "" {
		return errors.New("a workflow instance ID is required")
	}

	if req.EventName == "" {
		return errors.New("an event name is required")
	}

	// Input is also optional. However, inputs are expected to be unprocessed string values (e.g. JSON text)
	var opts []api.RaiseEventOptions
	if len(req.EventData) > 0 {
		opts = append(opts, api.WithRawEventData(string(req.EventData)))
	}

	if err := d.client.RaiseEvent(ctx, api.InstanceID(req.InstanceID), req.EventName, opts...); err != nil {
		return fmt.Errorf("failed to raise event %s on workflow %s: %w", req.EventName, req.InstanceID, err)
	}

	d.logger.Debugf("Raised event %s on workflow instance '%s'", req.EventName, req.InstanceID)
	return nil
}

func (d *DurableTaskService) Get(ctx context.Context, req *workflows.GetRequest) (*workflows.StateResponse, error) {
	if req.InstanceID == "" {
		return nil, errors.New("a workflow instance ID is required")
	}

	metadata, err := d.client.FetchOrchestrationMetadata(ctx, api.InstanceID(req.InstanceID))
	if err != nil {
		if errors.Is(err, api.ErrInstanceNotFound) {
			d.logger.Errorf("Unable to get data on the instance: %s, no such instance exists", req.InstanceID)
			return nil, err
		}
		return nil, fmt.Errorf("failed to get workflow metadata for '%s': %w", req.InstanceID, err)
	}

	res := &workflows.StateResponse{
		Workflow: &workflows.WorkflowState{
			InstanceID:    req.InstanceID,
			WorkflowName:  metadata.Name,
			CreatedAt:     metadata.CreatedAt,
			LastUpdatedAt: metadata.LastUpdatedAt,
			RuntimeStatus: getStatusString(int32(metadata.RuntimeStatus)),
			Properties: map[string]string{
				"dapr.workflow.input":         metadata.SerializedInput,
				"dapr.workflow.custom_status": metadata.SerializedCustomStatus,
			},
		},
	}

	// Status-specific fields
	if metadata.FailureDetails != nil {
		res.Workflow.Properties["dapr.workflow.failure.error_type"] = metadata.FailureDetails.GetErrorType()
		res.Workflow.Properties["dapr.workflow.failure.error_message"] = metadata.FailureDetails.GetErrorMessage()
	} else if metadata.IsComplete() {
		res.Workflow.Properties["dapr.workflow.output"] = metadata.SerializedOutput
	}

	return res, nil
}

func (d *DurableTaskService) Pause(ctx context.Context, req *workflows.PauseRequest) error {
	if req.InstanceID == "" {
		return errors.New("a workflow instance ID is required")
	}

	if err := d.client.SuspendOrchestration(ctx, api.InstanceID(req.InstanceID), ""); err != nil {
		return fmt.Errorf("failed to pause workflow %s: %w", req.InstanceID, err)
	}

	d.logger.Debugf("Pausing workflow instance '%s'", req.InstanceID)
	return nil
}

func (d *DurableTaskService) Resume(ctx context.Context, req *workflows.ResumeRequest) error {
	if req.InstanceID == "" {
		return errors.New("a workflow instance ID is required")
	}

	if err := d.client.ResumeOrchestration(ctx, api.InstanceID(req.InstanceID), ""); err != nil {
		return fmt.Errorf("failed to resume workflow %s: %w", req.InstanceID, err)
	}

	d.logger.Debugf("Resuming workflow instance '%s'", req.InstanceID)
	return nil
}

func (d *DurableTaskService) PurgeWorkflow(ctx context.Context, req *workflows.PurgeRequest) error {
	if req.InstanceID == "" {
		return errors.New("a workflow instance ID is required")
	}

	if err := d.client.PurgeOrchestrationState(ctx, api.InstanceID(req.InstanceID)); err != nil {
		if errors.Is(err, api.ErrInstanceNotFound) {
			d.logger.Warnf("The requested instance: '%s' does not exist or has already been purged", req.InstanceID)
			return err
		}
		return fmt.Errorf("failed to purge workflow %s: %w", req.InstanceID, err)
	}

	d.logger.Debugf("Purging workflow instance '%s'", req.InstanceID)
	return nil
}

func getStatusString(status int32) string {
	if statusStr, ok := statusMap[status]; ok {
		return statusStr
	}
	return "UNKNOWN"
}

func (c *DurableTaskService) GetComponentMetadata() (metadataInfo contribmeta.MetadataMap) {
	metadataStruct := metadata{}
	contribmeta.GetMetadataInfoFromStructType(reflect.TypeOf(metadataStruct), &metadataInfo, contribmeta.WorkflowType)
	return
}
